# page 0

당신의 첫번째 라이브러리.



요약 : 본 프로젝트의 목적은 흔히 쓰이는 함수들을 재편성한 C 라이브러리를 코드화하기 위한
것입니다. 그것은 다른 모든 프로젝트에서 사용할 수 있게 될 것입니다.

# page 2

Chapter 1

Introduction



매우 유용한 표준 함수들을 사용할 수 없을 때 C 프로그래밍이 매우 지루해질 수 있습니다.
본 프로젝트는 이런 함수들을 다시 쓰고, 그것들을 이해하고, 그 함수들의 사용법을 배울 기
회를 제공합니다. 이 라이브러리는 나중에 진행할 C 프로젝트에 도움이 될 것입니다.

본 프로젝트를 통해서, 우리는 여러분이 만든 함수 리스트를 확장할 수 있는 기회를 제공합니
다. 시간을 내서 일 년 내내 당신의 libft를 확장하세요.

# Page 3

Chapter 2

Common Instructions



• 프로젝트는 Norm 규칙에 맞춰 작성되어야 합니다. 보너스 파일/함수가 있는 경우,해당 파일/함수
들은 norm 검사에 포함되며, norm error가 있을 시, 0점을 받게 될것입니다.
• 함수들은 정의되지 않은 행동들과는 별개로 예기치 않게 중단되어서는 안 됩니다.(예를 들어,
segmentation fault, bus error, double free 등.)
• 필요한 경우 heap에 할당된 모든 메모리 공간은 적절하게 해제되어야 합니다. 메모리 누수는 용
납되지 않을 것입니다.
• 그 과제에서 필요한 경우, Makefile을 제출해야 합니다. 그것은 -Wall -Wextra -Werror 플래그를
지정하여 컴파일할 것입니다. 그리고 Makefile은 relink 되어서는안됩니다.
• Makefile은 최소한 $(NAME), all, clean, fclean, re를 포함해야 합니다.
• 프로젝트에 보너스를 제출하려면, Makefile에 보너스 규칙을 포함해야 합니다. 이보너스 규칙은
프로젝트의 메인 부분에서 금지되었던 모든 다양한 헤더, 라이브러리,또는 함수들은 추가해야 할
것입니다. 보너스는 반드시 _bonus.{c/h}라는 다른 파일에 있어야 합니다. 의무적으로 해야 될 파
트과 보너스 파트는 별도로 평가될 것입니다.
• 프로젝트에서 여러분의 libft를 허용한다면, 소스들과 그것과 연관된 Makefile을 연관된 Makefile과
함께 libft폴더에 복사해야 합니다. 프로젝트의 Makefile은 Makefile을 사용하여 라이브러리를 컴
파일한 다음, 프로젝트를 컴파일해야 합니다.
• 이 과제물을 제출할 필요가 없고, 채점 받을 필요가 없을지라도, 우리는 프로젝트를 위한 테스트 프로그램을 만들 것을 권장합니다. 그것은 여러분의 과제물과 동료들의 과제물을 쉽게 테스트할 기회를 제공할 것입니다. 평가하는 동안 이 테스트 프로그램들이 특히 유용하다는 것을 알게 될 것입니다. 사실, 평가하는 동안, 여러분의 테스트 프로그램과 평가 받는 동료의 테스트 프로그램들을 자유롭게 사용할 수 있을것입니다.
• 할당된 git 저장소에 과제물을 제출하세요. 오직 git 저장소에 있는 과제물만 등급이매겨질 것입
니다. 만약 과제를 평가받는데 Deepthought가 배정된다면, 그것은 동료평가 이후에 이루어질 것입니다. 만약 Deepthought 평가 중에 오류가 발생한다면, 그 즉시 평가는 중지될 것입니다.

# Page 4

Chpater 3

Mandatory part



3.1 Technical considerations

* 전역 변수는 사용할 수 없습니다.
* 복잡한 함수를 작성하기 위해 하위 함수가 필요한 경우에는, 이러한 하위 함수를 라이브러리와
  함께 배포하지하지 않도록 static(정적)으로 정의해야 합니다.

* 저장소의 root 위치에 있는 모든 파일을 제출하세요.

# Page 5

3.2 Part 1 - Libc functions

첫 번째 파트에서는, man에 정의되어 있는 대로 libc 함수들의 구성을 다시 코드화해야
합니다. 함수들은 원본과 같은 형식의 프로토타입을 선언해야 할 것입니다.
함수의 이름 앞에는 “ft_”를 붙여야 합니다. 예를 들어 strlen은 다음과 같이 됩니다.
ft_strlen.

```
노랭이
re-code해야하는 함수의 프로토타입의 일부는 “restrict” 한정자를 사용합니다. 이 키
워드는 c99 표준의 일부분입니다.
그러므로 프로토타입에 포함시키고 -std=c99 플래그를 사용하여 컴파일 하는 것은 금
지됩니다.
```

아래의 함수들을 다시 코드화해야 합니다. 이 함수들은 외부 함수들을 필요로 않습니다.

```
memset, bzero ...
```

아래의 함수들 또한 “malloc” 함수를 사용하여, 다시 코드화 해야 합니다.

```
strdup, calloc
```

# Page 6

3.3 Part 2 - Addtional fuctions

두 번째 파트에서는, libc에 포함되있지 않거나 다른 형식으로 포함된 함수들의 구성을 코드
화해야 합니다. 이러한 함수 중 일부는 파트1의 함수들을 쓰는 데 유용할 수 있습니다.

```
ft_substr, ft_strjoin ...
```

# Page 9

Chpater 4

Bonus part



필수적으로 해야 하는 모든 것을 성공적으로 끝냈다면, 한 걸음 더 나아가보는 것도 즐거운 일이 될 것입니다. 이 마지막 섹션을 보너스 점수로 볼 수 있습니다.

메모리와 문자열을 조작하는 함수를 갖는 것은 매우 유용하지만, 곧 리스트를 조작하는 함
수를 갖는 것이 훨씬 더 유용하다는 것을 알게 될 것입니다.

다음의 구조를 사용하여 리스트의 요소들을 표현하세요. 이 구조를 libft.h 파일에 추가해야
합니다.

​	make bonus 는 libft.a에 보너스 함수들을 추가할 것입니다.

이 파트의 헤더와 .c파일에 보너스를 추가할 필요는 없습니다. 자신의 보너스 함수들이 포함된
파일에만 _bonus를 추가하세요.

```
typedef struct s_list
{
	void 			*content;
	struct s_list 	*next;
}				 	t_list;
```

여기 t_list 구조체의 필드에 대한 설명이 있습니다.

• content : 요소에 포함된 데이터. void 포인터는 어떠한 종류의 자료형이든 저장할 수
있습니다.
• next : 마지막 요소인 경우에는 NULL. 또는 다음 요소의 주소.

# Page 10

아래의 함수들은 리스트를 쉽게 사용할 수 있게 해줄 것입니다.

```
ft_lstnew, ft_lstadd_front ...
```

# Page 12

적합하다고 생각한다면, 자신의 libft에 어떠한 함수들도 자유롭게 추가시킬 수 있습니다.